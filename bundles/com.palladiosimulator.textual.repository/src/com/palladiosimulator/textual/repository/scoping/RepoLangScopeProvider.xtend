/*
 * generated by Xtext 2.10.0
 */
package com.palladiosimulator.textual.repository.scoping

import com.google.common.base.Function
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.MapBasedScope
import org.palladiosimulator.pcm.repository.PrimitiveDataType
import org.palladiosimulator.pcm.repository.Repository
import org.palladiosimulator.pcm.repository.RepositoryPackage
import org.palladiosimulator.pcm.resourcetype.ResourceType
import org.palladiosimulator.pcm.resourcetype.ResourcetypePackage
import org.palladiosimulator.pcm.resourcetype.ResourceRepository
import com.palladiosimulator.textual.repository.repoLang.SeffExternalCallAction
import com.palladiosimulator.textual.repository.repoLang.RepoLangPackage
import com.palladiosimulator.textual.repository.repoLang.Component
import com.palladiosimulator.textual.repository.repoLang.Seff
import com.palladiosimulator.textual.repository.repoLang.SeffCallParameter

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class RepoLangScopeProvider extends AbstractRepoLangScopeProvider {

	Iterable<IEObjectDescription> primitiveTypesDescriptions
	Iterable<IEObjectDescription> resourceTypesDescriptions
	static final val TYPES_URI = "pathmap://PCM_MODELS/PrimitiveTypes.repository"
	static final val RESOURCE_TYPES_URI = "pathmap://PCM_MODELS/Palladio.resourcetype"

	new() {
		val types = loadPrimitiveTypes.filter(typeof(PrimitiveDataType))
		primitiveTypesDescriptions = Scopes.scopedElementsFor(types, new Function<PrimitiveDataType, QualifiedName>() {

			override apply(PrimitiveDataType input) {
				QualifiedName.create(input.type.getName())
			}
		});
		
		val resTypes = loadResourceTypes//.filter(typeof(ResourceType))
		resourceTypesDescriptions = Scopes.scopedElementsFor(resTypes, new Function<ResourceType, QualifiedName>() {

			override apply(ResourceType input) {
				QualifiedName.create(input.entityName)
			}
		});
		
	}

	override getScope(EObject context, EReference reference) {
		val scope = super.getScope(context, reference)

		if (RepositoryPackage.eINSTANCE.dataType.isSuperTypeOf(reference.EReferenceType)) {
			return MapBasedScope.createScope(scope, primitiveTypesDescriptions)
		}
		else if (ResourcetypePackage.eINSTANCE.resourceType.isSuperTypeOf(reference.EReferenceType)) {
			return MapBasedScope.createScope(scope, resourceTypesDescriptions)
		}
		
		if (context instanceof SeffExternalCallAction && 
			reference == RepoLangPackage.Literals.SEFF_EXTERNAL_CALL_ACTION__CALLED
		) {
			val extCall =  context as SeffExternalCallAction;
			if(extCall.role != null) {
				val candidates = extCall.role.interface.signature
				return Scopes.scopeFor(candidates)
			}
			
			val component = context.findComponent
			val candidates = component.requires.map[interface.signature].flatten
        	return Scopes.scopeFor(candidates)
		}
		else if (context instanceof SeffExternalCallAction && 
			reference == RepoLangPackage.Literals.SEFF_EXTERNAL_CALL_ACTION__ROLE
		) {
			val component = context.findComponent
			val candidates = component.requires
        	return Scopes.scopeFor(candidates)
		}
		else if (context instanceof SeffExternalCallAction && 
			reference == RepoLangPackage.Literals.SEFF_CALL_PARAMETER__PARAMETER
		) {
			val method = (context as SeffExternalCallAction).called
			val candidates = method.parameters
        	return Scopes.scopeFor(candidates)
		}
		else if (context instanceof SeffCallParameter && 
			reference == RepoLangPackage.Literals.SEFF_CALL_PARAMETER__PARAMETER
		) {
			val method = (context.eContainer as SeffExternalCallAction).called
			val candidates = method.parameters
        	return Scopes.scopeFor(candidates)
		}
		else if (context instanceof Seff && 
			reference == RepoLangPackage.Literals.SEFF__SIGNATURE
		) {
			val component = context.findComponent
			val candidates = component.provides.map[interface.signature].flatten
        	return Scopes.scopeFor(candidates)
		}
		
		
		
		return scope
	}
	
	def Component findComponent(EObject action)
	{
		var parent = action.eContainer
		while(!(parent instanceof Component))
			parent = parent.eContainer 
		
		return parent as Component
	}

	
	def loadResourceTypes() {
		val rs = new ResourceSetImpl();
		val res = rs.getResource(URI.createURI(RESOURCE_TYPES_URI), true)
		res.load({
		})
		return res.contents.filter(typeof(ResourceRepository)).head.availableResourceTypes_ResourceRepository
	}

	def loadPrimitiveTypes() {
		val rs = new ResourceSetImpl();
		val res = rs.getResource(URI.createURI(TYPES_URI), true)
		res.load({
		})
		return res.contents.filter(typeof(Repository)).head.dataTypes__Repository
	}

}
